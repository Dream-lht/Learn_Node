## 一、全局对象
### 1.1 Process 全局对象
    1.  给Node传递一些参数
        1.  直接在控制台传递参数，
            ``
                node 01-index.js name=coderwhy age=18 
                argv: [
                    'C:\\Program Files\\nodejs\\node.exe',
                    'D:\\Code\\Node\\2.全局对象和模块化开发\\01.node传递参数.js',
                    'name=coderwhy',    //从外部传入的参数
                    'age=18'            //从外部传入的参数
                ],
            ``
    2.  获取参数：通过Process对象当中的argv数组来获取
    3.  为什么叫argv呢？
        1. argument vector 的缩写，在C++当中，vector是一种类似数组的数据结构

### 1.2 Node输出
    1. console.log 在控制台输出
    2. console.clear 清空控制台
    3. console.trace 打印函数的调用栈

### 1.3 常见的全局对象
    1. 文档的全局对象模块Globals
    2. Process 提供Node进程当中的信息 包括运行环境，参数信息，node版本
    3. console 对象 
    4. 定时器对象 
       1. setTimeout  延迟多少秒之后执行
       2. setInterval  多少秒简谱循环执行
       3. setImmediate  立即执行
       4. proces.nextTick
    5. global 

### 1.4 特殊的全局对象（模块变量）
    1. __diranme  获取当前文件所在绝对路径名称（不包含文件名）
    2. __filename 获取当前文件所在的绝对路径（包含文件名）
    3. export
    4. module
    5. require()

## 二、JavaScript的模块化
### 2.1什么是模块化
    将程序划分为一个一个的结构，每个结构都有知己的逻辑代码，还有自己的作用域，不会影响其他的结构，这个结构也可以对外暴露变量、函数、对象等，也可以通过某种方式导入其他结构的变量，函数，对象
### 2.2 模块化规范
    1. AMD
    2. CMD
    3. **CommonJS**
    4. **ES2015**

### 2.3 JavaScript没有模块化的解决方案
    1. 立即函数调用表达式（IIFE）
       //定义变量来接收返回值，然后共享出去
         var moduleBar = (functions(){
             var name = "晓丽";
            
        //导出对象name
         return {
             name:name,
         };
     })()


    //在foo.js调用
    console.log(moduleBar.name);
    2. 缺点
           1. 命名难以规范
           2. 代码混乱不堪
           3. 没有统一的规范
### 2.4 CommonJS和Node
```javascript
1.  exports和require
    1.  exports 导出模块当中的变量，函数
        exports.name = name;
        exports.age = age;
    2.  require 导入其他模块的变量，函数
        var bar = require('./bar.js');
        console.log(bar.name);
    3.  Node当中CommonJS的实现原理
        1.  exports是一个模块的全局变量，实际上，他是一个空对象 exports === {}；在内存当中，栈当中保存exports对象的指针，堆内存当中保存{}
        2.  require导入的其实是exports对象的指针，所有实际上是两个模块都对exports对象进行的引用
        3.  当其中一个模块对导入/导出对象进行更改的时候，其他使用的模块也会跟随变化  
```

2.![01_CommonJS在Node当中的实现原理](D:\Code\Node\2.全局对象和模块化开发\image\01_CommonJS在Node当中的实现原理.png)

### 2.5 module.exports

1. module.exports在Node当中的体现

   1. 在CommonJS当中是没有module.exports概念的
   2. 为了实现模块的导出，Node使用的是Module的类，每一个模块都是Module的实例，也就是module
   3. 所以在Node当中真正的导出其实根本不是exports，而是module.exports,所以module才是真正的实现者

2. module.exports与export和require三者之间的关系

3. ![02_module.exports](D:\Code\Node\2.全局对象和模块化开发\image\02_module.exports.png)

4. exports存在的意义

   是NodeJS对CommonJS规范的一个妥协，因为CommonJS规范当中规定必须与一个exports导出

### 2.6 require（X）

1. **X**直接以文件开头的，没有./，则导入的是Node的内置模块，要是内置模块没有，则查询当前文件路径下的文件
2. **X**是以./或../或/（根目录）开头的
   1. 如果文件以后缀名，按照后缀名的格式查找对应的文件
   2. 如果没有后缀名，会按照如下顺序：
      1. 直接查找文件X
      2. 查找X.js文件
      3. 查找X.json文件
      4. 查找X.node文件
3. 如果没有找到对应的文件，则将X作为一个目录
   1. 查找目录下面的Index文件：
      1. 查找X/index.js文件
      2. 查找X/index.json文件
      3. 查找X/index.node文件
4. 直接是一个X，没有路径，也没有核心模块，那么他会去当前目录的node_module当中查询，如果没找到会到上一层目录当中查找，依次查找，没找到报错not found

### 2.7 模块的加载

1. Node当中CommonJS加载是同步的，并且每次加载模块的时候，模块内部的代码会被执行依次，但当模块多次加载，里面的代码会被缓存，只会加载一次
2. module当中的loader变量记录了模块是否被加载

3. 如果循环引用，加载顺序是深度优先，因为模块的循环引用是一种数据结构——图结构，在图的遍历当中以深度优先和广度优先的算法，Node采用的是深度优先算法：main->aaa->ccc->ddd->eee->bbb
4. ![03_module加载过程](D:\Code\Node\2.全局对象和模块化开发\image\03_module加载过程.png)

### 2.8 ES Module

1. **export**导出方式

   1. 直接导出变量

      ```
      export const name = "李慧涛";
      export const age = 18;
      export sayHello = () => {
      	console.log("sayHello");
      }
      ```

   2. {}当中统一导出，这里要注意：**{}并不是一个对象，在这里面不能使用键值对的形式，只有存放变量的引用**

      ```js
      const name = "李慧涛";
      const age = 18;
      sayHello = () => {
      	console.log("sayHello");
      }
      
      //{放置要导出的变量的引用列表}
      export {
      	name,
      	age,
      	sayHello
      }
      ```

   3. {}导出时，可以给变量起别名

      ~~~js
      const name = "李慧涛";
      const age = 18;
      sayHello = () => {
      	console.log("sayHello");
      }
      
      export {
      	name as fName,
          age as fAge,
      }
      ~~~

2. **import**导入方式

   1. 直接导入

      ```js
      //注意，在导入文件的时候，文件必须添加后缀名
      import {name,age,sayHello} from './module/foo.js'
      ```

   2. 起别名

      ~~~js
      import {name  as fname ,age as fAge ,sayHello as fSayHello } from './module/foo.js'
      ~~~

   3. ***   as  **   方式

      ~~~js
      import * as info from './module/foo.js'
      ~~~

3. **default**使用方法

   1. **default**默认导出，不需要导出名字

      ~~~js
      export default function (){
      	console.log("aaa");
      }
      ~~~

4. **import()**使用

   ~~~js
   let falg = true;
   if(falg){
       import('./modules/foo.js').then( (res) => {
           console.log(res);
       }).catch( (err) => {
           console(err)
       })
   }
   ~~~

5. **ES Module**加载过程

   1. ES Module加载js文件的过程是编译(解析)时加载的，并且是**异步**的

      1. 编译（解析）时加载，意味着import不能和运行时相关内容放在一起使用
      2. 比如from后面的路径需要动态获取
      3. 不能将import放到if等语句块当中
      4. 所以我们也成es module是静态解析的，而不是动态或者运行时解析的

   2. 异步意味着：JS引擎在遇到import时会去获取这个js文件，但是这个获取是异步的 ，并不会阻塞主线程的执行

   3. 也就是说，设置了type=module的代码，相当于script标签也加上了async属性，如果之后的普通script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞他们的执行

      ~~~js
      <script src="./foo.js" type="module"></script>
      //上面的js文件并不会阻塞下面的js文件执行，因为上面的type=module，所以差不多加上了async
      <script src="./foo.js" ></script>
      ~~~

6. ![04_esModule加载过程](D:\Code\Node\2.全局对象和模块化开发\image\04_esModule加载过程.png)

7. 对象当中的属性在index.js当中是可以修改了，因为对象在堆内存当中以自己的空间，这里常量保存的只是引用地址

~~~js
//index.js
// 这里对foo模块进行导入
import {name,age,info}from "./module/foo.js";

// 更改foo模块当中的变量
console.log(name);
setTimeout( () => {
    name = "777";
},1000)


//foo.js
let name = "张三";
let age = 18;
const info = {
    color:"#fff",
}

/**
 * 导出变量的引用，相当于把变量的地址导出，然后在内存当中新开辟一块空间，创建一个模块环境记录，
 * 这个环境记录是实时的，就算foo当中的变量在之后发生变化，他也会重新对变量进行绑定
 * */ 
export{
    name,
    age,
    info,
}

setTimeout( () => {
    console.log(name); //Assignment to constant variable. 不能修改常量
})
~~~

### 2.9 CommJS和ES Module之间的交互

1. 通常情况下，CommonJS不能加载ES Module
   1. 因为CommJS是同步加载的，但是ES Module必须静态分析等，无法这个之后执行代码JavaScript代码
   2. 但是某些平台也可以特地的针对代码进行解析
   3. Node当中是不支持的
2. 多数情况下ES Module可以加载CommonJS
   1. ES Module在加载CommonJS时，会将module.exports导出的内容作为default导出方式使用

